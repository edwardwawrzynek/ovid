# Ovid Compiler Pass Description

Compilation takes place in passes. Code is compiled by compilation unit (file). 

Between some passes, information is exchanged between different compilation units. When this happens, all the compilation process (or threads or whatever) are stopped, and the shared information is written to header files, shared in memory, etc.

### Pass 1 (Parsing)
The first pass runs on the file, and it tokenizes and parses it into an ast.

As it encounters variable declarations (var or func), it adds an entry to the name scope stack. This entry does not contain any type information.

As it encounters type declarations (aliases, named structs, interfaces, etc), it adds an entry to the type scope stack. This entry includes the ast::Type tree generated by the parser (which may contain unresolved refrences to type symbols).

### First Exchange
The contents of the name and type scope tables are exchanged.

For the name table, this is just basic information -- name, pub/private.

For the type table, this is the name, but also a representation of the parsed type ast (with unresolved information).

### Pass 2 (Resolve Pass)
The first pass resolves references to identifiers, and resolves type alias trees.

When the pass encounters an identifier, it finds it in the name scope tables (or throws error if not found). It modifies the ast to point to the scope table entry.

When the pass encounters an annotated variable/arg/whatever declaration, it resolves it's type (see below).

When the pass comes to a type alias declaration (type alias decl, struct decl, etc) or usage (function argument type annotation, etc), it looks it up in the type table (or throws error if not present). 

If the pass hasn't seen this type before, it visits it's alias tree (type aliases, struct field types, etc). If there are unresolved types in that tree, it resolves them by lookups in the type scope table. If it finds an unidentified type, it throws an error (TODO: this leads to duplicate errors as multiple compilation processes visit the same type).

### Second Exchange

The contents of the name and type scope tables are exchanged.

At this point, the name tables contain resolved type information (for non inferred types, at least).

All aliases in the type tables are resolved.

Basically full type information is available for non-inferred variables and all types (struct field's types, etc, alias trees resolved).

### Type Checking

The type checker runs on the ast. It performs type inference where needed. As it runs, it converts the code to a mid level IR:

This IR is not SSA, but it is a typed representation of the ast in linear instead of tree form. 

Certain constructs, such as if's, loops, etc, have been broken down into labels and jumps. 

Complex expressions have been broken down into individual operations to perform.

Memory allocations have been made explicit (for escape analysis, see below).

Implicit type conversions (struct -> interface, type -> union type, etc) have been made explicit.

Type declarations, etc, are not present in the IR. The IR contains only function's code. When LLVM needs type declarations, they can be extracted fully from the type scope tables.

### IR -> LLVM
The mid level IR is converted to LLVM IR.

An escape analyzer is run on the mid level IR. It tracks each allocated variable, and determines if a pointer to it escapes the function. Once complete, it marks whether each allocation needs to go on the stack or the heap.

TODO: the escape analyzer should generate information about input pointers escape (if they flow to other inputs, results, globals, etc). Eventually this would allow cross function escape analysis. Right now, just assume any pointer passed to a function escapes.

TODO: purity analysis? (useful to confirm that overloaded operations are pure)

The IR is visited and converted to LLVM IR. More generic nodes in the IR, such as allocations, type conversions, etc, get converted to the appropriate instruction(s) in LLVM.